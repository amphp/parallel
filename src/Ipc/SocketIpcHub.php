<?php declare(strict_types=1);

namespace Amp\Parallel\Ipc;

use Amp\Cancellation;
use Amp\CancelledException;
use Amp\DeferredFuture;
use Amp\Socket;
use Amp\Socket\ResourceSocket;
use Amp\Socket\SocketAddressType;
use Amp\TimeoutCancellation;
use Revolt\EventLoop;

final class SocketIpcHub implements IpcHub
{
    public const DEFAULT_KEY_RECEIVE_TIMEOUT = 5;
    public const DEFAULT_KEY_LENGTH = 64;

    private int $nextId = 0;

    /** @var non-empty-string */
    private string $uri;

    /** @var int[] */
    private array $keys = [];

    /** @var DeferredFuture[] */
    private array $acceptor = [];

    /** @var \Closure(): void */
    private \Closure $accept;

    /**
     * @param float $keyReceiveTimeout Timeout to receive the key on accepted connections.
     * @param positive-int $keyLength Length of the random key exchanged on the IPC channel when connecting.
     */
    public function __construct(
        private readonly Socket\ServerSocket $server,
        float $keyReceiveTimeout = self::DEFAULT_KEY_RECEIVE_TIMEOUT,
        private readonly int $keyLength = self::DEFAULT_KEY_LENGTH,
    ) {
        $address = $this->server->getAddress();
        $this->uri = match ($address->getType()) {
            SocketAddressType::Unix => 'unix://' . $address->toString(),
            SocketAddressType::Internet => 'tcp://' . $address->toString(),
        };

        $keys = &$this->keys;
        $acceptor = &$this->acceptor;
        $this->accept = static function () use (&$keys, &$acceptor, $server, $keyReceiveTimeout, $keyLength): void {
            while (!empty($acceptor) && $client = $server->accept()) {
                try {
                    $received = readKey($client, new TimeoutCancellation($keyReceiveTimeout), $keyLength);
                } catch (\Throwable) {
                    $client->close();
                    continue; // Ignore possible foreign connection attempt.
                }

                $id = $keys[$received] ?? null;

                if ($id === null) {
                    $client->close();
                    continue; // Ignore possible foreign connection attempt.
                }

                $deferred = $acceptor[$id] ?? null;
                unset($acceptor[$id], $keys[$received]);

                if ($deferred === null) {
                    $client->close();
                    continue; // Client accept cancelled.
                }

                $deferred->complete($client);
            }
        };
    }

    public function __destruct()
    {
        $this->close();
    }

    public function isClosed(): bool
    {
        return $this->server->isClosed();
    }

    public function close(): void
    {
        $this->server->close();
    }

    public function onClose(\Closure $onClose): void
    {
        $this->server->onClose($onClose);
    }

    public function getUri(): string
    {
        return $this->uri;
    }

    public function generateKey(): string
    {
        return \random_bytes($this->keyLength);
    }

    /**
     * @param string $key A key generated by {@see generateKey()}.
     */
    public function accept(string $key, ?Cancellation $cancellation = null): ResourceSocket
    {
        if (\strlen($key) !== $this->keyLength) {
            throw new \ValueError(\sprintf(
                "Key provided is of length %d, expected %d",
                \strlen($key),
                $this->keyLength,
            ));
        }

        if (isset($this->keys[$key])) {
            throw new \Error("An accept is already pending for the given key");
        }

        $id = $this->nextId++;

        if (empty($this->acceptor)) {
            EventLoop::queue($this->accept);
        }

        $this->keys[$key] = $id;
        $this->acceptor[$id] = $deferred = new DeferredFuture;

        try {
            $client = $deferred->getFuture()->await($cancellation);
        } catch (CancelledException $exception) {
            unset($this->acceptor[$id], $this->keys[$key]);
            throw $exception;
        }

        return $client;
    }
}
